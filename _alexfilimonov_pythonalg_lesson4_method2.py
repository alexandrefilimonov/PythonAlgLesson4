#2a. Написать два алгоритма нахождения i-го по счёту простого числа.
#Первый - без использования «Решета Эратосфена»; проанализировать скорость и сложность алгоритмов. 
#Результаты анализа сохранить в виде комментариев в файле с кодом.

#Ниже представлена реализация алгоритма по памяти 

import math 

def primes(m):
    N = int(1.28036*m*math.log(0.677361*m+1.92947,math.exp(1))+4)  #N аппроксимируется по порядковому номеру простого числа, см. метод№3 для больших деталей  

    sieve = set(range(2, N))
    for i in range(2, int(math.sqrt(N))):
        if i in sieve:
            sieve -= set(range(2*i, N, i))

    #в sieve - все простые от 2 до N, возвращаем число с порядковым номером m
    return list(sieve)[m-1]

print("The 3rd Prime number is ", primes(3)) 
print("The 13th Prime number is ", primes(13)) 
 

#сложность алгоритма по памяти (не используя алгоритм «Решето Эратосфена») оценивается как O(√N) при нахождении всех простых чисел до N,
#однако же сложность вышеприведенного метода primes(m), где m - порядковый номер просто числа - O(√(m*ln(m))), поскольку N = a*m*ln(b*m+c). 





